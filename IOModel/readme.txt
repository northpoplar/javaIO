这个项目里会涉及到java的几个IO包的使用



参考  https://www.cnblogs.com/wade-luffy/p/6106030.html
看了很多关于IO模型的文章，这一篇终于让我明白了。


总结：
先从OS角度考虑怎么操作IO，包括两个步骤：准备数据即数据放到系统内核区域的过程(比如OS读取硬盘或者发起TCP握手)；拷贝数据即数据从内核区拷贝到用户区的过程
阻塞/非阻塞是针对第一个步骤而言，具体来说就是调用方发起函数recvfrom或者select给OS要求返回数据，那么OS接到函数请求之后去准备数据时就会产生阻塞非阻塞的概念，
如果请求方一直等待所有资源都准备好数据才返回那就是阻塞，而非阻塞则是调用后立刻返回(但是返回结果中会得知是否全部数据准备好了)，
还有一种情况就是不用等全部准备好就返回的情况，它到底是阻塞还是非阻塞，这个待定。

分几种场景详细解释
１、如果是只发了一次recvfrom，然后一直等待结果并且要等到所有的资源都准备好才返回(比如多个fd即文件描述符都准备好了)，那必然是阻塞。
如果等到所有资源都准备好了也不返回，而是继续等待OS把数据从内存的OS内核区拷贝到用户区，这个也是阻塞并且是同步阻塞
２、如果是多次发起recvfrom(可能针对每个资源都发起了一次或者每次发起都针对多个资源)，最后一次(所有资源都准备好了)才有了结果那就是非阻塞。
如果在这最后一次调用发起后，调用方还会等待OS把数据拷贝到用户区。这就是同步非阻塞。
３、如果是发起了一次select函数(前提是要事先注册多个待监听的资源)，然后只要监听的资源有数据准备好了就返回，这个也可以看作是非阻塞(就是前面说的待定)。
并且返回后会又发起recvfrom函数让OS去拷贝数据，然后等待，这也是同步非阻塞(精准的概念叫做IO复用)
这种场景又分为3种情况select函数、poll函数、epoll函数
select函数和poll函数都会把所有注册的资源全部拿到，然后扫描一边之后才知道到底哪些资源准备好了
select函数有资源个数的限制，poll则避免了这个限制
epoll则更先进，它只把准备好的资源告诉调用方，这样也避免了全部资源描述符在内核区和用户区之间的拷贝
４、如果调用方建立了信号处理机制，然后调用sigaction函数之后立即返回，OS准备好数据之后通过信号机制告知调用方，这明显是非阻塞。
调用方然后发起recvfrom函数，等待OS拷贝好数据，这个就是同步非阻塞(精准的概念叫做信号驱动)
５、异步非阻塞，就是调用方发起sio_read函数，立即返回，OS准备数据并且拷贝数据，之后才通知调用方(通过信号机制)

总结：
一个同步阻塞，三个同步非阻塞，一个异步非阻塞。没有异步阻塞。
数据从内核区拷贝到用户区必然由OS来操作


java中IO有三种类型，具体可以参考图片
1、同步阻塞，即BIO
jdk1.0
其中，又有两种情况：
没有使用线程池，一个线程对应一个请求；使用线程池，M个请求使用N个线程响应
ServerSocket

2、同步非阻塞，即NIO
jdk1.4
selector多路复用器，会有一个单独的IO线程轮询所有的请求，具体步骤
创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式。
创建Reactor线程，创建多路复用器(Selector)并启动线程。
将ServerSocketChannel注册到Reactor线程的Selector上。监听accept事件。
Selector在线程run方法中无线循环轮询准备就绪的Key。
Selector监听到新的客户端接入，处理新的请求，完成tcp三次握手，建立物理连接。
将新的客户端连接注册到Selector上，监听读操作。读取客户端发送的网络消息。
客户端发送的数据就绪则读取客户端请求，进行处理。
一个IO线程处理M个请求

3、异步非阻塞，即AIO
jdk1.7中引入了NIO2.0
创建AsynchronousServerSocketChannel，绑定监听端口
调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler。包括上一步，都是非阻塞的
连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler。
数据就绪，触发负责处理数据的CompletionHandler的completed方法。继续做下一步处理即可。
写入操作类似，也需要传入CompletionHandler。